#!/usr/bin/env ruby

class CollectionJsonResponse < SimpleDelegator
  extend Forwardable

  def_delegators :collection, :href, :links, :link, :items,
                 :template, :fill_template_field, :fill_template, :submit_template

  def collection
    @collection ||= Collection.new(body)
  end

  class Collection < SimpleDelegator
    def initialize(body)
      super body.fetch('collection')
    end

    def href
      fetch('href')
    end

    def links
      return [] unless has_key?('links')
      fetch('links').map {|link| Link.new(link) }
    end

    def link(relation)
      links.find {|link| link.relation == relation }
    end

    def template
      @template ||= Item.new(fetch('template'))
    end

    def fill_template_field(name, value)
      template[name] = value
    end

    def fill_template(item)
      item.to_hash.each do |name, value|
        p [name, value]
        fill_template_field name, value
      end
    end

    def items
      return [] unless has_key?('items')
      fetch('items').map {|item| Item.new(item) }
    end
  end

  class Link
    attr_accessor :relation, :href

    def initialize(link)
      @relation = link.fetch('rel')
      @href     = link.fetch('href')
    end
  end

  class Item
    attr_accessor :item

    def initialize(item)
      @item = item
    end

    def href
      @item.fetch('href')
    end

    def data
      @item.fetch('data')
    end

    def []=(name, value)
      datum = data.find {|datum| datum['name'] == name }
      return unless datum
      datum['value'] = value
    end

    def to_hash
      data.each_with_object({}) do |datum, data|
        data[datum['name']] = datum['value']
      end
    end
  end
end

def conn
  @conn ||= Faraday.new(url: 'https://api.getcloudapp.com') do |config|
    config.request  :url_encoded
    config.response :logger, logger
    config.response :json, :content_type => /\bjson$/
    config.adapter  Faraday.default_adapter
  end
end

def logger
  @logger ||= Logger.new(debug_output)
end

def debug_output
  @debug_output ||= StringIO.new
end

def reset_debug_output
  debug_output.rewind
  debug_output.truncate 0
end

def make_request(uri, data = {}, method = :unset)
  method = data.empty? ? :get : :post if method == :unset
  reset_debug_output
  @response = CollectionJsonResponse.new(conn.send(method, uri, data))
end

def get_root
  make_request '/'
end

def retry_request
  make_request @response.env[:url].request_uri
end

def section(banner)
  puts
  puts "-- #{banner} --"
  output = Output.new(1)
  yield output
  output.print '[empty]' if output.empty?
end

class Output
  attr_reader :level, :io
  def empty?() @empty end

  def initialize(level, io = $stdout)
    @level = level
    @io    = io
    @empty = true
  end

  def print(line = '')
    print_lines Array(line)
  end

  def print_lines(lines)
    @empty = false
    lines.each do |line|
      io.puts(indentation + line)
    end
  end

  def indentation
    '  ' * level
  end
end

def print_response
  section 'Request' do |out|
    out.print "#{@response.env[:method].upcase} #{@response.env[:url]}"
    out.print_lines @response.env[:request_headers].map {|header, value|
      "#{header}: #{value}"
    }
  end

  section 'Response' do |out|
    out.print_lines @response.headers.map {|header, value|
      "#{header}: #{value}"
    }
  end

  section 'Body' do |out|
    out.print_lines JSON.pretty_generate(@response.body).lines
  end

  section 'Links' do |out|
    out.print link_relations unless link_relations.empty?
  end
end

def link_relations
  @response.links.map(&:relation).join(', ')
end

def request_basic_authentication(username = :ask, password = :ask)
  username = ask('Username: ')                     if username == :ask
  password = ask('Password: ') {|q| q.echo = '*' } if password == :ask
  conn.basic_auth username, password
  retry_request
end

def request_token_authentication(token = '2x033S09401z300E')
  conn.headers['Authorization'] = "Token token=#{token.inspect}"
  retry_request
end

def follow_link(relation = :ask)
  relation = ask('Relation: ') if relation == :ask
  make_request @response.link(relation).href
end

def create_item
  loop do
    section 'Create Item' do |out|
      out.print_lines JSON.pretty_generate(@response.template.item).lines
    end

    puts
    puts 'Fill the template to create a new item.'
    name = ask('Name (empty to submit): ')
    break if name.empty?
    value = ask('Value: ')

    @response.fill_template_field name, value
  end

  make_request @response.collection.href, @response.template.to_hash
end

def update_item
  item = @response.collection.items.find do |item|
    section 'Item' do |out|
      out.print_lines JSON.pretty_generate(item.item).lines
    end

    puts
    response = ask('Select this item to update [y,n]? ') do |q|
      q.character = true
      q.validate  = /\A[yn]\Z/
    end

    response == 'y'
  end

  @response.fill_template item

  loop do
    section 'Update Item' do |out|
      out.print_lines JSON.pretty_generate(@response.template.item).lines
    end

    puts
    puts 'Fill the template to update the item.'
    name = ask('Name (empty to submit): ')
    break if name.empty?
    value = ask('Value: ')

    @response.fill_template_field name, value
  end

  make_request item.href, @response.template.to_hash, :put
end

def print_debug
  section 'Debug' do |out|
    debug_output.rewind
    out.print_lines debug_output.readlines
  end
end

def print_help
  puts <<EOS
    root:
      Go back to the root

    follow <rel>:
      Follow link with the given relation.

    template [<name>=<value>...]:
      Fill the template with the given name/value pairs and submit.

    basic [<username> [<password>]]:
      Authenticate with HTTP Basic and reload the current resource. Will be
      prompted for username and password if omitted.

    token <token>:
      Authenticate using the given token and reload the current resource.

    debug:
      Print debug output from the previous HTTP request and response.
EOS
end

def get_next_action
  command, args = ask_for_action
  case command
  when 'r', 'root'   then get_root
  when 'f', 'follow' then follow_link(*args)
  when      'create' then create_item
  when      'update' then update_item
  when 'b', 'basic'  then request_basic_authentication(*args)
  when 't', 'token'  then request_token_authentication(*args)
  when 'd', 'debug'  then print_debug; get_next_action
  when '?', 'help'   then print_help; get_next_action
  when 'q', 'quit'   then exit
  else puts 'Try again.'; get_next_action
  end
end

def ask_for_action
  puts
  input = ask('> ') {|q| q.readline = true }.split(/\s/)
  [ input.first, input[1..-1] ]
end

trap('INT') { puts; exit }

get_root
loop do
  print_response
  get_next_action
end

BEGIN {
  require 'delegate'
  require 'forwardable'
  require 'highline/import'
  require 'json'
  require 'faraday'
  require 'faraday_middleware'
  require 'logger'
  require 'stringio'
}
