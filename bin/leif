#!/usr/bin/env ruby

class CollectionJsonResponse < SimpleDelegator
  extend Forwardable

  def_delegators :collection, :links, :link

  def collection
    Collection.new body
  end

  class Collection < SimpleDelegator
    def initialize(body)
      super body.fetch('collection')
    end

    def links
      return [] unless has_key?('links')
      fetch('links').map {|link| Link.new(link) }
    end

    def link(relation)
      links.find {|link| link.relation == relation }
    end
  end

  class Link
    attr_accessor :relation, :href

    def initialize(link)
      @relation = link.fetch('rel')
      @href     = link.fetch('href')
    end
  end
end

def conn
  @conn ||= Faraday.new(url: 'https://api.getcloudapp.com') do |config|
    # config.response :logger
    config.response :json, :content_type => /\bjson$/
    config.adapter  Faraday.default_adapter
  end
end

def make_request(uri)
  @response = CollectionJsonResponse.new(conn.get(uri))
end

def get_root
  make_request '/'
end

def retry_request
  make_request @response.env[:url].request_uri
end

def section(banner)
  puts "-- #{banner} --"
  output = Output.new(1)
  yield output
  output.print '[empty]' if output.empty?
  output.print
end

class Output
  attr_reader :level, :io
  def empty?() @empty end

  def initialize(level, io = $stdout)
    @level = level
    @io    = io
    @empty = true
  end

  def print(line = '')
    print_lines Array(line)
  end

  def print_lines(lines)
    @empty = false
    lines.each do |line|
      io.puts(indentation + line)
    end
  end

  def indentation
    '  ' * level
  end
end

def print_response
  section 'Request' do |out|
    out.print "#{@response.env[:method].upcase} #{@response.env[:url]}"
    out.print_lines @response.env[:request_headers].map {|header, value|
      "#{header}: #{value}"
    }
  end

  section 'Response' do |out|
    out.print_lines @response.headers.map {|header, value|
      "#{header}: #{value}"
    }
  end

  section 'Body' do |out|
    out.print_lines JSON.pretty_generate(@response.body).lines
  end

  section 'Options' do |out|
    if @response.headers['www-authenticate']
      out.print 'Re-request using HTTP Basic Auth'
    end
    out.print "Links: #{link_relations}" unless link_relations.empty?
    out.print 'Go to root'
  end
end

def link_relations
  @response.links.map(&:relation).join(', ')
end

def request_basic_authentication(username, password = :ask)
  password = ask('Password: ') {|q| q.echo = '*' } if password == :ask
  conn.basic_auth username, password
  retry_request
end

def request_token_authentication(token = '2x033S09401z300E')
  conn.headers['Authorization'] = "Token token=#{token.inspect}"
  retry_request
end

def follow_link(relation = :ask)
  relation = ask('Relation: ') if relation == :ask
  make_request @response.link(relation).href
end

def print_help
  puts <<EOS
    root:
      Go back to the root

    follow <rel>:
      Follow link with the given relation.

    basic <username> [<password>]:
      Authenticate with HTTP Basic and reload the current resource. Will be
      prompted for password if it is omitted.

    token <token>:
      Authenticate using the given token and reload the current resource.
EOS
end

def get_next_action
  command, args = ask_for_action
  case command
  when 'r', 'root'   then get_root
  when 'f', 'follow' then follow_link(*args)
  when 'b', 'basic'  then request_basic_authentication(*args)
  when 't', 'token'  then request_token_authentication(*args)
  when '?', 'help'   then print_help; get_next_action
  when 'q', 'quit'   then exit
  else puts 'Try again.'; get_next_action
  end
end

def ask_for_action
  input = ask('> ') {|q| q.readline = true }.split(/\s/)
  [ input.first, input[1..-1] ]
end

trap('INT') { puts; exit }

get_root
loop do
  print_response
  get_next_action
end

BEGIN {
  require 'delegate'
  require 'forwardable'
  require 'highline/import'
  require 'json'
  require 'faraday'
  require 'faraday_middleware'
}
