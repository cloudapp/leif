#!/usr/bin/env ruby

def conn
  @conn ||= Faraday.new(url: 'https://api.getcloudapp.com') do |config|
    config.request  :url_encoded
    config.response :logger, logger
    config.response :json, :content_type => /\bjson$/
    config.adapter  Faraday.default_adapter
  end
end

def logger
  @logger ||= Logger.new(debug_output)
end

def debug_output
  @debug_output ||= StringIO.new
end

def reset_debug_output
  debug_output.rewind
  debug_output.truncate 0
end

def make_request(uri, data = {}, method = :unset)
  method = data.empty? ? :get : :post if method == :unset
  reset_debug_output
  @response = conn.send(method, uri, data)
end

def collection
  Leif::CollectionJson::Collection.new(@response.body)
end

def get_root
  make_request '/'
end

def retry_request
  make_request @response.env[:url].request_uri
end

def section(banner)
  puts
  puts "-- #{banner} --"
  output = Output.new(1)
  yield output
  output.print '[empty]' if output.empty?
end

class Output
  attr_reader :level, :io
  def empty?() @empty end

  def initialize(level, io = $stdout)
    @level = level
    @io    = io
    @empty = true
  end

  def print(line = '')
    print_lines Array(line)
  end

  def print_lines(lines)
    @empty = false
    lines.each do |line|
      io.puts(indentation + line)
    end
  end

  def indentation
    '  ' * level
  end
end

def print_response
  section 'Request' do |out|
    out.print "#{@response.env[:method].upcase} #{@response.env[:url]}"
    out.print_lines @response.env[:request_headers].map {|header, value|
      "#{header}: #{value}"
    }
  end

  section 'Response' do |out|
    out.print_lines @response.headers.map {|header, value|
      "#{header}: #{value}"
    }
  end

  section 'Body' do |out|
    out.print_lines JSON.pretty_generate(@response.body).lines
  end

  section 'Links' do |out|
    unless collection.link_relations.empty?
      out.print collection.link_relations.join(', ')
    end
  end
end

def request_basic_authentication(username = :ask, password = :ask)
  username = ask('Username: ')                     if username == :ask
  password = ask('Password: ') {|q| q.echo = '*' } if password == :ask
  conn.basic_auth username, password
  retry_request
end

def request_token_authentication(token = '2x033S09401z300E')
  conn.headers['Authorization'] = "Token token=#{token.inspect}"
  retry_request
end

def follow_link(relation = :ask)
  relation = ask('Relation: ') if relation == :ask
  make_request collection.link_href(relation)
end

def create_item
  template = collection.collection_template

  loop do
    section 'Create Item' do |out|
      out.print_lines JSON.pretty_generate(template).lines
    end

    puts
    puts 'Fill the template to create a new item.'
    name = ask('Name (empty to submit): ')
    break if name.empty?
    value = ask('Value: ')

    template = template.fill_field name, value
  end

  make_request template.href, template.convert_to_json, template.method
end

def update_item
  item = collection.items.find do |item|
    section 'Item' do |out|
      out.print_lines JSON.pretty_generate(item).lines
    end

    puts
    response = ask('Select this item to update [y,n]? ') do |q|
      q.character = true
      q.validate  = /\A[yn]\Z/
    end

    response == 'y'
  end

  template = collection.item_template item

  loop do
    section 'Update Item' do |out|
      out.print_lines JSON.pretty_generate(template).lines
    end

    puts
    puts 'Fill the template to update the item.'
    name = ask('Name (empty to submit): ')
    break if name.empty?
    value = ask('Value: ')

    template = template.fill_field name, value
  end

  make_request template.href, template.convert_to_json, template.method
end

def print_debug
  section 'Debug' do |out|
    debug_output.rewind
    out.print_lines debug_output.readlines
  end
end

def print_help
  puts <<EOS
    root:
      Go back to the root

    follow <rel>:
      Follow link with the given relation.

    template [<name>=<value>...]:
      Fill the template with the given name/value pairs and submit.

    basic [<username> [<password>]]:
      Authenticate with HTTP Basic and reload the current resource. Will be
      prompted for username and password if omitted.

    token <token>:
      Authenticate using the given token and reload the current resource.

    debug:
      Print debug output from the previous HTTP request and response.
EOS
end

def get_next_action
  command, args = ask_for_action
  case command
  when 'r', 'root'   then get_root
  when 'f', 'follow' then follow_link(*args)
  when      'create' then create_item
  when      'update' then update_item
  when 'b', 'basic'  then request_basic_authentication(*args)
  when 't', 'token'  then request_token_authentication(*args)
  when 'd', 'debug'  then print_debug; get_next_action
  when '?', 'help'   then print_help; get_next_action
  when 'q', 'quit'   then exit
  else puts 'Try again.'; get_next_action
  end
end

def ask_for_action
  puts
  input = ask('> ') {|q| q.readline = true }.split(/\s/)
  [ input.first, input[1..-1] ]
end

trap('INT') { puts; exit }

get_root
loop do
  print_response
  get_next_action
end

BEGIN {
  require 'highline/import'
  require 'json'
  require 'faraday'
  require 'faraday_middleware'
  require 'logger'
  require 'stringio'
  require 'leif/collection_json'
}
